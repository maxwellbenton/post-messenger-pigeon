class Store{constructor(){this._registry={},this._prefix=""}get prefix(){return this._prefix}set prefix(e){this._prefix=e}get registry(){return this._registry}register(e,s){this._registry[e]=s}unregister(e){delete this._registry[e]}isRegistered(e){return!!this._registry[e]}}class Messenger{constructor(){this._store=new Store,window.addEventListener("message",(async e=>{console.log("MESSAGE RECEIVED",e);const{data:s,origin:t,source:r}=e,i=JSON.parse(s);if(this.isRegistered(i.messageName)){let e;try{e=await this.store.registry[i.messageName]({origin:t,source:r,data:i}),console.log("END OF MESSAGE LISTENER CALLBACK",e)}catch(e){console.log("Error in callback",e)}}}))}createMessage(e,s,t){const r=JSON.stringify({messageName:e,...s&&Object.keys(s).length&&{data:s},...t&&{origin:t}});return console.log("CREATED MESSAGE",r),r}register(e,s){this._store.register(e,s)}unregister(e){this._store.unregister(e)}isRegistered(e){return this._store.isRegistered(e)}get registry(){this._store.registry}messagePrefix(){return this._store.prefix}get store(){return this._store}setMessagePrefix(e){this._store.prefix=e}async _listen(e,s,t,r=!0){const i=this.store.prefix+"."+e;let o,n;console.log("LISTENING",i,s);const a=new Promise(((o,a)=>{this.register(i,(async i=>{r&&this.unregister(e);const{data:a,origin:g,source:c}=i;if(!t?.domain||t.domain===g){if(console.log("CALLBACK",s),n=await s(a),console.log("CALLBACK RESULT",n),!a.messageName.endsWith(".acknowledged")){const e=this.createMessage(a.messageName+".acknowledged",n);this._broadcast(c,e,g)}r&&o(n)}}))})),g=new Promise(((e,s)=>{o=()=>{this.unregister(i),e()}}));return Object.assign(Promise.race([a,g]),{cancel:o})}bootstrap(e){this.setMessagePrefix(e),this._listen("handshake",(e=>{console.log("INSIDE HANDSHAKE CALLBACK",e);const s=e?.data?.messageName;return{messageName:s,registered:this.isRegistered(s)}}),{},!1)}_broadcast(e,s,t){console.log("BROADCASTING",s,t),e.postMessage(s,t)}on(e,s={},t=(e=>e)){if(!e)throw new Error("Message name is required");return this._listen(e,t,s,!1)}async once(e,s={},t=(e=>e)){if(!e)throw new Error("Message name is required");return this._listen(e,t,s,!0)}async send(e,s,t){if(!e)throw new Error("Message name is required");const r=this.store.prefix,i=r+"."+e;console.log("STARTING SEND",i,s,t);let o=new Promise(((o,n)=>{s?.timeout&&setTimeout((()=>n(new Error("Timeout"))),s.timeout),this._listen("handshake.acknowledged",(e=>e),{window:window.parent},!0).then((r=>{if(console.log("HANDSHAKE ACKNOWLEDGED",r),!r?.data?.registered)throw new Error(`No listener registered for ${i}`);{this._listen(e+".acknowledged",(e=>e),s,!0).then((e=>{console.log("MESSAGE ACKNOWLEDGED",e),o(e)}));const r=this.createMessage(i,t);console.log("SENDING MESSAGE",r),this._broadcast(s.window,r,s.origin)}}));const a=this.createMessage(r+".handshake",{messageName:i});console.log("SENDING HANDSHAKE",a),this._broadcast(s.window,a,s.origin)}));return await o}}modules.export={bootstrap:bootstrap,on:on,once:once,send:send};
